using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace LesApp0
{
    class Program
    {
        static void Main()
        {
            // Підтримка Unicode
            Console.OutputEncoding = Encoding.Unicode;

            // Дуже заплутано і не зрозуміло написане формулювання завдання
            // "...у чисел, которые являются степенью двойки..."
            // в даному випадку згідно цього формулювання, звертається увага
            // на число яке є степінню основи числа 2, тобто a = 2^n
            // тобто говориться наче б то про "n". В той час як згідно найденій
            // інформації в інтернеті, звертається увага на "a".
            // А бачу формулювання так: Проаналізувати/перевірити чи введене
            // користувачем число, дорівнює степеневій/показниковій функції
            // (з основою)/(при основі) 2 та цілим спепенем. Або: перевірити 
            // чи задане число є результатом 2 (двійки) з цілим (степенем) / (степенневим числом)...

            // Підтримка Unicode
            Console.OutputEncoding = Encoding.Unicode;

            // Введення числа
            Console.WriteLine("Введіть ціле число:\n");
            Console.Write("\ta = ");
            int a = int.Parse(Console.ReadLine());

#if true    // інтернетний варіант, що базується на побітовій логіці

            // взято з інтернету
            // головна особливість, те що лише один - останній біт
            // має значення "1", а всі інші "0". Oтже:
            // a > 0 і
            // 1. Варіант: a & (a - 1) == 0
            // 2. Варіант: a & (a + 1) == a

#if false  // 1. Варіант
            if ((a & (a - 1)) == 0 && a > 0)
            {
                Console.WriteLine("\nВведене Вами число дорівнює двійці з цілим степенем: a = 2^n де n є N.");
            }
            else
            {
                Console.WriteLine("\nВведене Вами число не дорівнює двійці з цілим степенем.");
            }
#endif

#if false  // 2. Варіант - недолік дагого варіанту в тому, що базовий вираз не враховує "1" що є 2^0, в той час як 1-й враховує
            if (((a & (a + 1)) == a && a > 0) || (a == 1))
            {
                Console.WriteLine("\nВведене Вами число дорівнює двійці з цілим степенем: a = 2^n де n є N");
            }
            else
            {
                Console.WriteLine("\nВведене Вами число не дорівнює двійці з цілим степенем.");
            }
#endif
#endif

#if true    // власний варіант, що базується на математичних формулах

            // маємо вираз : a = 2^n
            // при умові n є N (цілі, натуральні числа), тобто n > 0
            // розв'язуємо рівння, для аналізу по "n"
            // log_2(a) = log_2(2^n) - логарифм по основі 2 
            // n = log_2(a), при цьомиу накладається обмеження, що a > 0
            // саме воно і використано у варіантах вище

            // виникає наступна проблема, в деяких мовах програмування
            // відсутні логарифми з можливістю задавати довільну основу
            // але згідно мат правил можна скористатися формулою
            // log_a(b) = log_c(b) / log_c(a), де с > 0
            // зазвичай обирають або с = e => ln(x), або с = 10 => lg(x)

            double res = 0;

            if (a > 0)
            {
                res = Math.Log(a) / Math.Log(2);
            }

            // перевірка
            if ((a > 0) && (res % 1 == 0))
            {
                Console.WriteLine("\nВведене Вами число дорівнює двійці з цілим степенем: a = 2^n де n є N");
            }
            else
            {
                Console.WriteLine("\nВведене Вами число не дорівнює двійці з цілим степенем.");
            }
#endif

            #region Повторення
            Console.WriteLine("\nСпробувати ще раз: [т, н]");
            Console.Write("\t");
            var button = Console.ReadKey();

            if ((button.KeyChar.ToString().ToLower() == "т") ||
                (button.KeyChar.ToString().ToLower() == "n")) // можливо забули переключити розкладку клавіатури
            {
                Console.Clear();
                Main();
            }
            #endregion
        }
    }
}
